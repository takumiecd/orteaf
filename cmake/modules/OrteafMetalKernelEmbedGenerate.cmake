# Generate Metal kernel registry implementation for ORTEAF.
# Required variables:
#   OUTPUT - destination .cpp file
#   KERNEL_RECORDS - serialized list (kernel_name:symbol_prefix:obj_file)

if(NOT DEFINED OUTPUT)
    message(FATAL_ERROR "OrteafMetalKernelEmbedGenerate: OUTPUT not specified")
endif()
if(NOT DEFINED KERNEL_RECORDS)
    message(FATAL_ERROR "OrteafMetalKernelEmbedGenerate: KERNEL_RECORDS not specified")
endif()

get_filename_component(_gen_dir "${OUTPUT}" DIRECTORY)
if(NOT IS_DIRECTORY "${_gen_dir}")
    file(MAKE_DIRECTORY "${_gen_dir}")
endif()

set(content "// Auto-generated by OrteafMetalKernelEmbedGenerate.cmake -- DO NOT EDIT\n")
string(APPEND content "#include \"orteaf/internal/backend/mps/metal_kernel_embed_api.h\"\n")
string(APPEND content "#include <array>\n")
string(APPEND content "#include <string_view>\n")
string(APPEND content "#include <cstddef>\n\n")
string(APPEND content "namespace orteaf::internal::backend::mps::metal_kernel_embed {\n\n")

set(declarations "extern \"C\" {\n")
set(entry_list)
string(REPLACE "|" ";" record_list "${KERNEL_RECORDS}")
set(declared_prefixes)

foreach(record ${record_list})
    if(record STREQUAL "")
        continue()
    endif()
    string(REPLACE ":" ";" parts "${record}")
    list(LENGTH parts part_count)
    if(part_count LESS 2)
        message(FATAL_ERROR "Invalid Metal kernel record '${record}'")
    endif()
    list(GET parts 0 kernel_name)
    list(GET parts 1 prefix)

    list(FIND declared_prefixes "${prefix}" prefix_index)
    if(prefix_index EQUAL -1)
        string(APPEND declarations "extern const unsigned char ${prefix}_start[];\n")
        string(APPEND declarations "extern const unsigned char ${prefix}_end[];\n")
        list(APPEND declared_prefixes "${prefix}")
    endif()

    list(APPEND entry_list "Entry{\"${kernel_name}\", ${prefix}_start, ${prefix}_end}")
endforeach()
string(APPEND declarations "}\n\n")
string(APPEND content "${declarations}")

string(APPEND content "namespace {\n")
string(APPEND content "struct Entry {\n")
string(APPEND content "    const char* name;\n")
string(APPEND content "    const unsigned char* begin;\n")
string(APPEND content "    const unsigned char* end;\n")
string(APPEND content "};\n")
string(APPEND content "}\n\n")

list(LENGTH entry_list entry_count)
if(entry_count EQUAL 0)
    string(APPEND content "static constexpr std::array<Entry, 0> entries = {};\n\n")
else()
    string(APPEND content "static constexpr std::array<Entry, ${entry_count}> entries = {\n")
    foreach(line ${entry_list})
        string(APPEND content "    ${line},\n")
    endforeach()
    string(APPEND content "};\n\n")
endif()

string(APPEND content "MetallibBlob find_library_data(std::string_view library_name) {\n")
string(APPEND content "    for (const Entry& entry : entries) {\n")
string(APPEND content "        if (std::string_view(entry.name) == library_name) {\n")
string(APPEND content "            return {entry.begin, static_cast<std::size_t>(entry.end - entry.begin)};\n")
string(APPEND content "        }\n")
string(APPEND content "    }\n")
string(APPEND content "    return {nullptr, 0};\n")
string(APPEND content "}\n\n")

string(APPEND content "bool available(std::string_view library_name) {\n")
string(APPEND content "    MetallibBlob blob = find_library_data(library_name);\n")
string(APPEND content "    return blob.data != nullptr && blob.size > 0;\n")
string(APPEND content "}\n\n")

string(APPEND content "MPSFunction_t load_embedded_function(MPSDevice_t device,\n")
string(APPEND content "                                     std::string_view library_name,\n")
string(APPEND content "                                     std::string_view function_name,\n")
string(APPEND content "                                     MPSError_t* error) {\n")
string(APPEND content "#if defined(MPS_AVAILABLE) && defined(__OBJC__)\n")
string(APPEND content "    if (!device) {\n")
string(APPEND content "        if (error) { *error = create_error(\"orteaf.mps.kernel\", \"Invalid MPS device\"); }\n")
string(APPEND content "        return nil;\n")
string(APPEND content "    }\n")
string(APPEND content "    MetallibBlob blob = find_library_data(library_name);\n")
string(APPEND content "    if (blob.data == nullptr || blob.size == 0) {\n")
string(APPEND content "        if (error) { *error = create_error(\"orteaf.mps.kernel\", \"Embedded metallib not found\"); }\n")
string(APPEND content "        return nil;\n")
string(APPEND content "    }\n")
string(APPEND content "    MPSError_t local_error = nullptr;\n")
string(APPEND content "    MPSLibrary_t library = create_library_with_data(device, blob.data, blob.size, &local_error);\n")
string(APPEND content "    if (library == nil) {\n")
string(APPEND content "        if (error) { *error = local_error; } else if (local_error) { destroy_error(local_error); }\n")
string(APPEND content "        return nil;\n")
string(APPEND content "    }\n")
string(APPEND content "    if (local_error) { destroy_error(local_error); }\n")
string(APPEND content "    MPSFunction_t function = create_function(library, function_name);\n")
string(APPEND content "    if (function == nil) {\n")
string(APPEND content "        destroy_library(library);\n")
string(APPEND content "        if (error) { *error = create_error(\"orteaf.mps.kernel\", \"Failed to create MTLFunction\"); }\n")
string(APPEND content "        return nil;\n")
string(APPEND content "    }\n")
string(APPEND content "    destroy_library(library);\n")
string(APPEND content "    if (error) { *error = nullptr; }\n")
string(APPEND content "    return function;\n")
string(APPEND content "#else\n")
string(APPEND content "    (void)device; (void)library_name; (void)function_name; (void)error;\n")
string(APPEND content "    return nullptr;\n")
string(APPEND content "#endif\n")
string(APPEND content "}\n\n")

string(APPEND content "} // namespace orteaf::internal::backend::mps::metal_kernel_embed\n")

message(STATUS "OrteafMetalKernelEmbedGenerate: writing ${OUTPUT}")
file(WRITE "${OUTPUT}" "${content}")
if(NOT EXISTS "${OUTPUT}")
    message(FATAL_ERROR "Failed to create Metal kernel registry at ${OUTPUT}")
endif()

#pragma once

#if ORTEAF_ENABLE_CUDA

#include <orteaf/internal/execution/cuda/platform/wrapper/cuda_types.h>

#include <cstddef>
#include <span>
#include <string_view>

#ifndef ORTEAF_EMBED_HAS_FATBIN
#define ORTEAF_EMBED_HAS_FATBIN 0
#endif
#ifndef ORTEAF_EMBED_HAS_CUBIN
#define ORTEAF_EMBED_HAS_CUBIN 0
#endif
#ifndef ORTEAF_EMBED_HAS_PTX
#define ORTEAF_EMBED_HAS_PTX 0
#endif

namespace orteaf::internal::execution::cuda::platform::wrapper::kernel_embed {

/**
 * @brief Access embedded CUDA kernel blobs generated by CMake.
 *
 * Each `.cu` file under `orteaf/src/extension/kernel/cuda/impl` is compiled
 * during the build and packed into the final binary as a `fatbin`, `cubin`, or
 * `ptx` blob (see `ORTEAF_CUDA_KERNEL_FORMATS`).  The helpers in this namespace
 * provide a lightweight registry that lets you enumerate and load those blobs
 * without re-reading files from disk.
 *
 * @par Usage example
 * @code{.cpp}
 * using namespace orteaf::internal::execution::cuda::platform::wrapper::kernel_embed;
 *
 * // Prefer a fatbin, but fall back to any available blob automatically.
 * Blob bin = findKernelData("embed_test_library", CudaKernelFmt::Fatbin);
 * if (!bin.data) {
 *     throw std::runtime_error("Kernel not embedded in this build");
 * }
 *
 * CUmodule module{};
 * ORTEAF_CUDA_DRIVER_CHECK(cuModuleLoadData(&module, bin.data));
 * CUfunction fn{};
 * ORTEAF_CUDA_DRIVER_CHECK(cuModuleGetFunction(&fn, module, "my_kernel"));
 * // ... enqueue kernel with cuLaunchKernel/cudaLaunchKernel ...
 *
 * // Or, load directly from embedded data:
 * auto embedded = createEmbeddedModule("embed_test_library");
 * @endcode
 */

enum class CudaKernelFmt { Fatbin, Cubin, Ptx };

constexpr const char* toString(CudaKernelFmt fmt) noexcept {
    switch (fmt) {
    case CudaKernelFmt::Fatbin: return "fatbin";
    case CudaKernelFmt::Cubin: return "cubin";
    case CudaKernelFmt::Ptx: return "ptx";
    }
    return "unknown";
}

struct Blob {
    const void* data;
    std::size_t size;
};

struct KernelEntry {
    const char* name;
    CudaKernelFmt fmt;
    const unsigned char* begin;
    const unsigned char* end;
};

std::span<const KernelEntry> kernels();

Blob findKernelData(std::string_view name,
                    CudaKernelFmt prefer = CudaKernelFmt::Fatbin);

bool available(std::string_view name);

::orteaf::internal::execution::cuda::platform::wrapper::CudaModule_t
createEmbeddedModule(std::string_view name,
                     CudaKernelFmt prefer = CudaKernelFmt::Fatbin);

} // namespace orteaf::internal::execution::cuda::platform::wrapper::kernel_embed

#endif  // ORTEAF_ENABLE_CUDA
